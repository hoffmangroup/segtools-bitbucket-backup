{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/hoffmanlab/segtools.json"}, "html": {"href": "#!/hoffmanlab/segtools"}, "avatar": {"href": "data/bytebucket.org/ravatar/{981b7f63-4900-4255-97c0-c244f833a3ee}ts=python"}}, "type": "repository", "name": "segtools", "full_name": "hoffmanlab/segtools", "uuid": "{981b7f63-4900-4255-97c0-c244f833a3ee}"}, "links": {"attachments": {"href": "data/repositories/hoffmanlab/segtools/issues/44/attachments_page=1.json"}, "self": {"href": "data/repositories/hoffmanlab/segtools/issues/44.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segtools/issues/44/watch"}, "comments": {"href": "data/repositories/hoffmanlab/segtools/issues/44/comments_page=1.json"}, "html": {"href": "#!/hoffmanlab/segtools/issues/44/segtools-aggregate-in-gene-mode-not"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segtools/issues/44/vote"}}, "reporter": {"display_name": "Micka\u00ebl Mendez", "uuid": "{3e035b9e-0328-44e8-8622-5c7e9ed060b2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3e035b9e-0328-44e8-8622-5c7e9ed060b2%7D"}, "html": {"href": "https://bitbucket.org/%7B3e035b9e-0328-44e8-8622-5c7e9ed060b2%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1cb7d89dcab61313d21c5ef402c28e11d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "Mickael Mendez", "type": "user", "account_id": "557058:aae10d90-ba66-49cd-a04d-5392b943760d"}, "title": "Segtools aggregate in gene mode not necessarily pick the longest transcript", "component": null, "votes": 0, "watches": 1, "content": {"raw": "When running segtools aggregate in gene mode  against a gencode annotation, I noticed that the number of features used to aggregate is much lower than expected. My gencode annotation file contains about 50 000 gene annotations whereas segtools only uses 20 000.\r\n\r\nThis is caused by the following lines (l. 127-134) from the aggregation.py  module:\r\n``` python\r\n# Start with establishing a dict:\r\n#   gene_id -> dict(transcript_id -> (chrom, start, end, name, strand))\r\n#   start is 0-indexed, end is non-inclusive (BED)\r\ngene_dict = defaultdict(partial(defaultdict, list))\r\nfor row in self._iter_rows(filename, verbose=verbose):\r\n            ...\r\n    # Add feature to dict\r\n    gene_dict[row['gene_id']][row['transcript_id']].append(row)\r\n```\r\nThe problem is that gencode 'gene' annotations (where feature field == 'gene') have the same gene_id and transcript_id:\r\n```\r\nchr1    HAVANA  gene    11869   14409   .       +       .       gene_id \"ENSG00000223972.3\"; transcript_id \"ENSG00000223972.3\"; gene_type \"pseudogene\"; gene_status \"KNOWN\"; gene_name \"DDX11L1\"; transcript_type \"pseudogene\"; transcript_status \"KNOWN\"; transcript_name \"DDX11L1\"; level 2; havana_gene \"OTTHUMG00000000961.2\"\r\n```\r\nSo when filling the `gene_dict` above, the 'gene' annotation line will be considered as a 'transcript' annotation. Later on, when calculating the longest transcript, the function `_get_longest_transcript(transcript_dict)` will certainly pick the 'gene' annotation as the longest transcript, unless there is a transcript that has 1) the exact same length as the gene annotation, and 2) is evaluated before the 'gene' annotation.\r\n\r\nWhen the 'gene' annotation is selected as the longest transcript, it won't be processed since it as no exons.\r\n\r\nTo test this, I compared the number of features used for aggregation from an original gencode file and a modified one where I removed all the 'gene' annotation lines:\r\n\r\nWith an original gencode file:\r\n```\r\nINFO:Aggregating over 20730 features\r\n```\r\n\r\nWith a gencode file without 'gene' annotation line:\r\n```\r\nINFO:Aggregating over 51082 features\r\n```\r\n", "markup": "markdown", "html": "<p>When running segtools aggregate in gene mode  against a gencode annotation, I noticed that the number of features used to aggregate is much lower than expected. My gencode annotation file contains about 50 000 gene annotations whereas segtools only uses 20 000.</p>\n<p>This is caused by the following lines (l. 127-134) from the aggregation.py  module:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># Start with establishing a dict:</span>\n<span class=\"c1\">#   gene_id -&gt; dict(transcript_id -&gt; (chrom, start, end, name, strand))</span>\n<span class=\"c1\">#   start is 0-indexed, end is non-inclusive (BED)</span>\n<span class=\"n\">gene_dict</span> <span class=\"o\">=</span> <span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">defaultdict</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_iter_rows</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">):</span>\n            <span class=\"o\">...</span>\n    <span class=\"c1\"># Add feature to dict</span>\n    <span class=\"n\">gene_dict</span><span class=\"p\">[</span><span class=\"n\">row</span><span class=\"p\">[</span><span class=\"s1\">&#39;gene_id&#39;</span><span class=\"p\">]][</span><span class=\"n\">row</span><span class=\"p\">[</span><span class=\"s1\">&#39;transcript_id&#39;</span><span class=\"p\">]]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>The problem is that gencode 'gene' annotations (where feature field == 'gene') have the same gene_id and transcript_id:</p>\n<div class=\"codehilite\"><pre><span></span>chr1    HAVANA  gene    11869   14409   .       +       .       gene_id &quot;ENSG00000223972.3&quot;; transcript_id &quot;ENSG00000223972.3&quot;; gene_type &quot;pseudogene&quot;; gene_status &quot;KNOWN&quot;; gene_name &quot;DDX11L1&quot;; transcript_type &quot;pseudogene&quot;; transcript_status &quot;KNOWN&quot;; transcript_name &quot;DDX11L1&quot;; level 2; havana_gene &quot;OTTHUMG00000000961.2&quot;\n</pre></div>\n\n\n<p>So when filling the <code>gene_dict</code> above, the 'gene' annotation line will be considered as a 'transcript' annotation. Later on, when calculating the longest transcript, the function <code>_get_longest_transcript(transcript_dict)</code> will certainly pick the 'gene' annotation as the longest transcript, unless there is a transcript that has 1) the exact same length as the gene annotation, and 2) is evaluated before the 'gene' annotation.</p>\n<p>When the 'gene' annotation is selected as the longest transcript, it won't be processed since it as no exons.</p>\n<p>To test this, I compared the number of features used for aggregation from an original gencode file and a modified one where I removed all the 'gene' annotation lines:</p>\n<p>With an original gencode file:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">INFO</span><span class=\"o\">:</span><span class=\"n\">Aggregating</span> <span class=\"n\">over</span> <span class=\"mi\">20730</span> <span class=\"n\">features</span>\n</pre></div>\n\n\n<p>With a gencode file without 'gene' annotation line:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">INFO</span><span class=\"o\">:</span><span class=\"n\">Aggregating</span> <span class=\"n\">over</span> <span class=\"mi\">51082</span> <span class=\"n\">features</span>\n</pre></div>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2016-07-04T21:54:14.420965+00:00", "milestone": null, "updated_on": "2016-09-21T15:47:59.569190+00:00", "type": "issue", "id": 44}